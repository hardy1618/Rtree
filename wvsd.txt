
// void bulkloadbottom(string location, int N){
// 	FileHandler fh= fm.OpenFile("Testcases/TC_1/sortedData_2_10_100.txt");
// 	FileHandler zero = fm.CreateFile("0.txt");
// 	levelfiles.push_back(zero);
// 	level.push_back(0);
// 	PageHandler pageone= zero.NewPage();
// 	levelpages.push_back(pageone);
// 	PageHandler ph = fh.FirstPage();
// 	char *data = ph.GetData ();
// 	char *pagedata= pageone.GetData();
// 	int count=0;
// 	int countread=1;
// 	int countpoints=0;
// 	int node[nodesize];
// 	loop(i,0,d){
// 		node[d+3+i]=INT_MIN;
// 		node[2*d+3+i]= INT_MAX;
// 	}
// 	int ids=0; // count number of nodes
// 	loop(i,0,N){
// 		// if(level[0]%pagecap ==0 && level[0]!=0){  //count says number of nodes. when pagecap reached-- add new page.
// 		// 	cout<<"Naya page bana"<<endl;
// 		// 	levelfiles[0].MarkDirty(pageone.GetPageNum());
// 		// 	levelfiles[0].UnpinPage(pageone.GetPageNum());
// 		// 	pageone=zero.NewPage();
// 		// 	pagedata= pageone.GetData();
// 		// 	count=0;
// 		// }
// 		node[0]=ids;
// 		int num;
// 		loop(j,0,d){
// 			if(countread==page_size){   //if reader page is full and needs new page
// 				countread=0;
// 				ph=fh.NextPage(ph.GetPageNum());
// 				data=ph.GetData();
// 			}
// 			memcpy (&num, &data[countread], intsize);
// 			node[d+3+j]=max(node[d+3+j],num);
// 			node[2*d+3+j]=min(node[2*d+3+j],num);
// 			node[2*d+3 + countpoints*(2*d+1)+j]=num;
// 			countread+=intsize;
// 		}
// 		if(countpoints==maxcap){   //if maxcap number of points are processed -- make neew node
// 			memcpy (&pagedata[level[0]*nodesize], &node, intsize*nodesize);

// 			fun(0);  //calling function to deal with level wise increment

// 			countpoints=0;
// 			ids++;
// 			loop(j,0,nodesize) node[j]=0;
// 			loop(j,0,d){
// 				node[d+3+j]=INT_MIN;
// 				node[2*d+3+j]= INT_MAX;
// 			}
// 		}
// 		countpoints++;
// 	}
// 	fm.CloseFile(fh);
// 	fm.CloseFile(zero);
// }